kafka的
ack=-1/all 
优点:leader在确认所有follower都同步后,进行回复kafka,这个情况只要确保至少有一台follower没有挂,就能保证消息成功发送
缺点:可能造成脏读或者消息多次消费
解决方案:
1.保证消息的幂等性,kafka中可以配置此选项,kafka的生产者会生成一个单调递增的pid,当broker接受到pid不等于系统最新接收的pid+1时,会拒绝接收此消息
进而保证只消费一次

2.设置max.in.flight.requests.per.connection参数:
默认值是5 设置为1能保证严格有序
官方解释:在阻塞之前，客户端将在单个连接上发送的未确认请求的最大数量。注意，如果这个设置设置为大于1并且有失败的发送，那么重试(即它启用了重试)会有消息重新排序的风险。
设置为1 会阻塞其他pid的提交,进而严格保证pid的有序性


分析:
以上只能解决单个消息发送到消息队列的原子性,如一个事务中,需要有3条消息同时发送到消息队列,一条失败则回滚的方案还是不能保证
因此 kafka引入事务,通常Kafka的事务分为
1.生产者事务Only
    解决多条消息的原子性
2.消费者&生产者事务
    场景为:消费者首先拿到数据,然后下游还存在业务失败的可能,需要进行事务回滚,此时消费的数据应该回滚
    
一般来说默认消费者消费的消息的级别是read_uncommited数据，这有可能读取到事务失败的数据，所有在开启生产者事务之后，需要用户设置消费者的事务隔离级别。
开启的生产者事务的时候，只需要指定transactional.id属性即可
一旦开启了事务，默认生产者就已经开启了幂等性。
但是要求"transactional.id"的取值必须是唯一的，同一时刻只能有一个"transactional.id"存储在，其他的将会被关闭。

消费者&生产者事务
此事务消费者端使用手动提交偏移量, 每次成功消费一个记录 并成功得到想要的结果的情况下才提交偏移量
此次消费的消息作为下一个或者多个生产者消息发送到下游消息队列 需开启生产者only事务
但是 存在生产者only事务或者 消费者端提交偏移量不是原子操作,所以此事务中, kafka提供了原子操作
提交生产者only事务并提交偏移量